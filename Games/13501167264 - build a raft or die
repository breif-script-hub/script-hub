-- this checks if player has connected to right place.
if game.PlaceId == 13501167264 then
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local UserInputService = game:GetService("UserInputService")
    local Debris = game:GetService("Debris")
    local RunService = game:GetService("RunService")
-- this loads the ui libery
    local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/breif-script-hub/script-hub/refs/heads/main/Dependencies%20/%20side%20scrips/Rayfield"))()
-- this creates the window we use for script hub.
    local Window = Rayfield:CreateWindow({
        Name = "Build a raft or die",
        Icon = 0,
        LoadingTitle = "Script Hub",
        LoadingSubtitle = "by Breif",
        ShowText = "Rayfield",
        Theme = "Default",
        ToggleUIKeybind = "K",
        DisableRayfieldPrompts = false,
        DisableBuildWarnings = true,
        ConfigurationSaving = {
            Enabled = true,
            FolderName = "script_hub_configs",
            FileName = "default_config"
        },
        Discord = {
            Enabled = false,
            Invite = "noinvitelink",
            RememberJoins = true
        },
        KeySystem = false
    })

    local MainTab = Window:CreateTab("Main")

    local MiscTab = Window:CreateTab("misc")
    local VisTab = Window:CreateTab("visual")
    -- fly code
        local flying = false
        local flySpeed = 50
        local bodyGyro, bodyVelocity
        local UIS = game:GetService("UserInputService")
        local RS = game:GetService("RunService")
        local player = game.Players.LocalPlayer
        local hrp

        local directions = {
            Forward = false, Backward = false, Left = false, Right = false, Up = false, Down = false
        }

        UIS.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed or not flying then return end
            local key = input.KeyCode
            if key == Enum.KeyCode.W then directions.Forward = true end
            if key == Enum.KeyCode.S then directions.Backward = true end
            if key == Enum.KeyCode.A then directions.Left = true end
            if key == Enum.KeyCode.D then directions.Right = true end
            if key == Enum.KeyCode.Space then directions.Up = true end
            if key == Enum.KeyCode.LeftControl then directions.Down = true end
        end)

        UIS.InputEnded:Connect(function(input)
            if not flying then return end
            local key = input.KeyCode
            if key == Enum.KeyCode.W then directions.Forward = false end
            if key == Enum.KeyCode.S then directions.Backward = false end
            if key == Enum.KeyCode.A then directions.Left = false end
            if key == Enum.KeyCode.D then directions.Right = false end
            if key == Enum.KeyCode.Space then directions.Up = false end
            if key == Enum.KeyCode.LeftControl then directions.Down = false end
        end)

        local function getDirectionVector()
            local cam = workspace.CurrentCamera
            local moveVector = Vector3.new()
            if directions.Forward then moveVector += cam.CFrame.LookVector end
            if directions.Backward then moveVector -= cam.CFrame.LookVector end
            if directions.Right then moveVector += cam.CFrame.RightVector end
            if directions.Left then moveVector -= cam.CFrame.RightVector end
            if directions.Up then moveVector += cam.CFrame.UpVector end
            if directions.Down then moveVector -= cam.CFrame.UpVector end
            return moveVector.Magnitude > 0 and moveVector.Unit * flySpeed or Vector3.new()
        end

        local flyConnection
        local function startFly()
            flying = true
            hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            bodyGyro = Instance.new("BodyGyro", hrp)
            bodyGyro.P = 9e4
            bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
            bodyGyro.CFrame = hrp.CFrame
            bodyVelocity = Instance.new("BodyVelocity", hrp)
            bodyVelocity.Velocity = Vector3.new()
            bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
            flyConnection = RS.RenderStepped:Connect(function()
                if flying then
                    bodyGyro.CFrame = workspace.CurrentCamera.CFrame
                    bodyVelocity.Velocity = getDirectionVector()
                end
            end)
        end

        local function stopFly()
            flying = false
            if flyConnection then flyConnection:Disconnect() flyConnection = nil end
            if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
            if bodyVelocity then bodyVelocity:Destroy() bodyVelocity = nil end
            for k in pairs(directions) do directions[k] = false end
        end

        MiscTab:CreateToggle({
            Name = "Fly",
            CurrentValue = false,
            Flag = "flyToggle",
            Callback = function(value)
                if value then startFly() else stopFly() end
            end
        })

        MiscTab:CreateSlider({
            Name = "Fly Speed",
            Range = {50, 700},
            Increment = 1,
            Suffix = "Speed",
            CurrentValue = flySpeed,
            Flag = "flySpeedSlider",
            Callback = function(value)
                flySpeed = value
            end
        })
        -- no clip code
        local noclip = false
        local noclipConnection
        MiscTab:CreateToggle({
            Name = "NoClip",
            CurrentValue = false,
            Flag = "noclipToggle",
            Callback = function(value)
                noclip = value
                if noclip and not noclipConnection then
                    noclipConnection = game:GetService("RunService").Stepped:Connect(function()
                        local char = player.Character
                        if char then
                            for _, v in pairs(char:GetDescendants()) do
                                if v:IsA("BasePart") then v.CanCollide = false end
                            end
                        end
                    end)
                elseif not noclip and noclipConnection then
                    noclipConnection:Disconnect()
                    noclipConnection = nil
                end
            end
        })
    -- code for walkspeed
    local currentWalkSpeed = 16
    local player = game.Players.LocalPlayer

    MiscTab:CreateSlider({
        Name = "WalkSpeed",
        Range = {16, 99},
        Increment = 1,
        Suffix = "Speed",
        CurrentValue = currentWalkSpeed,
        Callback = function(value)
            currentWalkSpeed = value
        end
    })
    task.spawn(function()
        while true do
            task.wait(0.01)
            local char = player.Character or player.CharacterAdded:Wait()
            local humanoid = char:FindFirstChildWhichIsA("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = currentWalkSpeed
            end
        end
    end)
    -- inf jump code
    local UserInputService = game:GetService("UserInputService")
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")

    local canInfJump = false


    UserInputService.JumpRequest:Connect(function()
        if canInfJump then
            if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end)

    MiscTab:CreateToggle({
        Name = "Infinite Jump",
        CurrentValue = false,
        Flag = "infJumpToggle",
        Save = true,
        Callback = function(value)
            canInfJump = value
        end
    })
    local player = game.Players.LocalPlayer
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local firetouchinterest = firetouchinterest or function() end -- failsafe

    local function touchPart(part)
        if part and part.Parent then
            firetouchinterest(player.Character.HumanoidRootPart, part, 0) -- touch begin
            task.wait(0.1)
            firetouchinterest(player.Character.HumanoidRootPart, part, 1) -- touch end
        end
    end

    -- this runs all functions required to win may need to use multiple times
    MainTab:CreateButton({
        Name = "Win",
        Callback = function()
            local player = game.Players.LocalPlayer
            local char = player.Character or player.CharacterAdded:Wait()
            local root = char:WaitForChild("HumanoidRootPart")


            local parts = {
                workspace.Checkpoints:GetChildren()[7],
                workspace.Checkpoints.Checkpoint,
                workspace.Checkpoints:GetChildren()[4],
                workspace.Checkpoints:GetChildren()[2],
                workspace.Checkpoints:GetChildren()[5],
                workspace.Checkpoints:GetChildren()[6],
                workspace.Checkpoints:GetChildren()[3],
                workspace.resetBlock
            }


            for _, part in ipairs(parts) do
                if part and part:IsA("BasePart") then
                    firetouchinterest(root, part, 0)
                    firetouchinterest(root, part, 1)
                    task.wait(0)
                else
                    warn("Invalid part:", part)
                end
            end
        end
    })
    local player = game.Players.LocalPlayer
    local firetouchinterest = firetouchinterest or function() end 
    local function runWinLoop()
        while _G.WinToggle do
            local char = player.Character or player.CharacterAdded:Wait()
            local root = char:WaitForChild("HumanoidRootPart")

            local parts = {
                workspace.Checkpoints:GetChildren()[7],
                workspace.Checkpoints.Checkpoint,
                workspace.Checkpoints:GetChildren()[4],
                workspace.Checkpoints:GetChildren()[2],
                workspace.Checkpoints:GetChildren()[5],
                workspace.Checkpoints:GetChildren()[6],
                workspace.Checkpoints:GetChildren()[3],
                workspace.resetBlock
            }

            for _, part in ipairs(parts) do
                if part and part:IsA("BasePart") then
                    firetouchinterest(root, part, 0)
                    firetouchinterest(root, part, 1)
                else
                    warn("Invalid part:", part)
                end
            end

            task.wait(0) 
        end
    end
-- this code spams win getting you lots of wins
    MainTab:CreateToggle({
        Name = "Auto win Toggle",
        CurrentValue = false,
        Flag = "WinToggle",
        Callback = function(value)
            _G.WinToggle = value
            if value then
                task.spawn(runWinLoop) 
            end
        end
    })


    MainTab:CreateButton({
        Name = "Remove Damage",
        Callback = function()
            local damageRemote = game:GetService("ReplicatedStorage"):FindFirstChild("Remotes") and game:GetService("ReplicatedStorage").Remotes:FindFirstChild("TakeDamage")
            if damageRemote then
                damageRemote:Destroy()
                print("TakeDamage Disabled")
            else
                warn("alreadyy disabled.")
            end
        end
    })
    -- loads my teleport ui.
    MainTab:CreateButton({
        Name = "Load Teleport Ui By Breif",
        Callback = function()
            loadstring(game:HttpGet("https://pastefy.app/f0XQxr9b/raw"))()
            notifyCustom("Teleport UI", "Teleport UI made by breif successfully loaded you can toggle it with right shiftt")
        end
    })
    -- Nametags
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")

    local nametagRadius = 2750
    local nametagEnabled = false
    local nametagFolder = Instance.new("Folder")
    nametagFolder.Name = "Nametags"
    nametagFolder.Parent = workspace

    local playerNametags = {}
    local localPlayer = Players.LocalPlayer

    local function createNametag(player)
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return nil end
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "NametagGui"
        billboard.Adornee = player.Character.HumanoidRootPart
        billboard.Size = UDim2.new(0, 100, 0, 30)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = nametagFolder

        local textLabel = Instance.new("TextLabel")
        textLabel.BackgroundTransparency = 1
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.Text = player.Name
        textLabel.TextColor3 = Color3.new(1, 1, 1)
        textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        textLabel.TextStrokeTransparency = 0
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.TextScaled = true
        textLabel.Parent = billboard

        return billboard
    end

    local function updateNametags()
        if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
        local localHRP = localPlayer.Character.HumanoidRootPart

        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= localPlayer then
                local char = plr.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    local distance = (char.HumanoidRootPart.Position - localHRP.Position).Magnitude
                    if distance <= nametagRadius then
                        if not playerNametags[plr] then
                            playerNametags[plr] = createNametag(plr)
                        end
                        if playerNametags[plr] then
                            playerNametags[plr].Enabled = true
                            playerNametags[plr].Adornee = plr.Character.HumanoidRootPart
                        end
                    else
                        if playerNametags[plr] then
                            playerNametags[plr].Enabled = false
                        end
                    end
                elseif playerNametags[plr] then
                    playerNametags[plr]:Destroy()
                    playerNametags[plr] = nil
                end
            end
        end
    end

    local function clearNametags()
        for _, gui in pairs(playerNametags) do
            if gui then gui:Destroy() end
        end
        playerNametags = {}
    end

    local function onPlayerAdded(player)
        if nametagEnabled and player ~= localPlayer then
            player.CharacterAdded:Connect(function()
                task.wait(1)
                if nametagEnabled then
                    if playerNametags[player] then playerNametags[player]:Destroy() end
                    playerNametags[player] = createNametag(player)
                end
            end)
        end
    end

    local function onPlayerRemoving(player)
        if playerNametags[player] then
            playerNametags[player]:Destroy()
            playerNametags[player] = nil
        end
    end

    local updateConnection
    local function toggleNametags(state)
        nametagEnabled = state
        if nametagEnabled then
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= localPlayer then
                    onPlayerAdded(player)
                end
            end
            updateConnection = RunService.RenderStepped:Connect(updateNametags)
            Players.PlayerAdded:Connect(onPlayerAdded)
            Players.PlayerRemoving:Connect(onPlayerRemoving)
        else
            if updateConnection then
                updateConnection:Disconnect()
                updateConnection = nil
            end
            clearNametags()
        end
    end

    VisTab:CreateToggle({
        Name = "Nametags",
        Flag = "NametagsToggle",
        Callback = function(state)
            toggleNametags(state)
            Rayfield:Notify({
                Title = "Nametags",
                Content = state and "Nametags Enabled" or "Nametags Disabled",
                Duration = 3
            })
        end
    })

    VisTab:CreateSlider({
        Name = "Nametag Radius",
        Range = {50, 10000},
        Increment = 10,
        CurrentValue = nametagRadius,
        Flag = "NametagRadiusSlider",
        Callback = function(value)
            nametagRadius = value
        end
    })
    -- player Teleportation
    MiscTab:CreateLabel("Player Teleportation")

    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local playerNames = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    if #playerNames == 0 then
        playerNames = {"No players found"}
    end

    local selectedPlayerName = nil

    local playerDropdown = MiscTab:CreateDropdown({
        Name = "Select Player",
        Options = playerNames,
        CurrentOption = playerNames[1],
        MultipleOptions = false,
        Flag = "PlayerDropdown",
        Callback = function(selection)
            selectedPlayerName = table.concat(selection, ", ")
            Rayfield:Notify({
                Title = "Player Selected",
                Content = "You selected: " .. selectedPlayerName,
                Duration = 3,
            })
        end
    })

    -- Teleport Button
    MiscTab:CreateButton({
        Name = "Teleport to Player",
        Callback = function()
            if selectedPlayerName == nil or selectedPlayerName == "No players found" then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "No valid target player selected.",
                    Duration = 3,
                })
                return
            end

            local targetPlayer = Players:FindFirstChild(selectedPlayerName)
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    LocalPlayer.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
                    Rayfield:Notify({
                        Title = "Teleported",
                        Content = "Teleported to " .. selectedPlayerName,
                        Duration = 3,
                    })
                else
                    Rayfield:Notify({
                        Title = "Error",
                        Content = "Your character or HumanoidRootPart not found.",
                        Duration = 3,
                    })
                end
            else
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Target player or HumanoidRootPart not found.",
                    Duration = 3,
                })
            end
        end
    })

    local function updateDropdownOptions()
        local newPlayerNames = {}
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                table.insert(newPlayerNames, player.Name)
            end
        end

        if #newPlayerNames == 0 then
            newPlayerNames = {"No players found"}
            selectedPlayerName = nil
        else
            if selectedPlayerName == nil or not table.find(newPlayerNames, selectedPlayerName) then
                selectedPlayerName = nil
            end
        end

        playerDropdown:Refresh(newPlayerNames)
    end

    Players.PlayerAdded:Connect(updateDropdownOptions)
    Players.PlayerRemoving:Connect(updateDropdownOptions);;

