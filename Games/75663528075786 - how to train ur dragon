-- loads rayfeild ui
local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/breif-script-hub/script-hub/refs/heads/main/Dependencies%20/%20side%20scrips/Rayfield"))()
-- creates the wnidow we will use
local Window = Rayfield:CreateWindow({
    Name = "how to train ur dragon",
    Icon = 0,
    LoadingTitle = "Script Hub",
    LoadingSubtitle = "by Breif",
    ShowText = "Rayfield",
    Theme = "Default",
    ToggleUIKeybind = "K",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = true,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "script_hub_configs",
        FileName = "default_config"
    },
    Discord = {
        Enabled = false,
        Invite = "noinvitelink",
        RememberJoins = true
    },
    KeySystem = false,
    KeySettings = {
        Title = "Untitled",
        Subtitle = "Key System",
        Note = "No method of obtaining the key is provided",
        FileName = "Key",
        SaveKey = true,
        GrabKeyFromSite = false,
        Key = {"Hello"}
    }
})

local MainTab = Window:CreateTab("Main")
local MiscTab = Window:CreateTab("misc")
local VisTab = Window:CreateTab("Visuuals")
-- gives u a  random fish
MainTab:CreateButton({
    Name = "Get Random Fish",
    Callback = function()
        local args = {3}
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("GetRandomFishRemoteEvent"):FireServer(unpack(args))
    end
})

-- this automatically spams giving u urandom fish with a wait ime of 0
local dupeActive = false
local dupeConnection

MainTab:CreateToggle({
    Name = "Dupe Random Fish",
    CurrentValue = false,
    Callback = function(Value)
        dupeActive = Value
        if dupeActive then
            dupeConnection = task.spawn(function()
                while dupeActive do
                    local args = {3}
                    game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("GetRandomFishRemoteEvent"):FireServer(unpack(args))
                    task.wait(0)
                end
            end)
        else
            if dupeConnection then
                task.cancel(dupeConnection)
            end
        end
    end
})
MainTab:CreateButton({
Name = "Load Teleport Ui By Breif",
Callback = function()
    loadstring(game:HttpGet("https://pastefy.app/f0XQxr9b/raw"))()
    notifyCustom("Teleport UI", "Teleport UI loaded successfully")
end
})
-- fly code
local flying = false
local flySpeed = 50
local bodyGyro, bodyVelocity
local UIS = game:GetService("UserInputService")
local RS = game:GetService("RunService")
local player = game.Players.LocalPlayer
local hrp

local directions = {
    Forward = false, Backward = false, Left = false, Right = false, Up = false, Down = false
}

UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or not flying then return end
    local key = input.KeyCode
    if key == Enum.KeyCode.W then directions.Forward = true end
    if key == Enum.KeyCode.S then directions.Backward = true end
    if key == Enum.KeyCode.A then directions.Left = true end
    if key == Enum.KeyCode.D then directions.Right = true end
    if key == Enum.KeyCode.Space then directions.Up = true end
    if key == Enum.KeyCode.LeftControl then directions.Down = true end
end)

UIS.InputEnded:Connect(function(input)
    if not flying then return end
    local key = input.KeyCode
    if key == Enum.KeyCode.W then directions.Forward = false end
    if key == Enum.KeyCode.S then directions.Backward = false end
    if key == Enum.KeyCode.A then directions.Left = false end
    if key == Enum.KeyCode.D then directions.Right = false end
    if key == Enum.KeyCode.Space then directions.Up = false end
    if key == Enum.KeyCode.LeftControl then directions.Down = false end
end)

local function getDirectionVector()
    local cam = workspace.CurrentCamera
    local moveVector = Vector3.new()
    if directions.Forward then moveVector += cam.CFrame.LookVector end
    if directions.Backward then moveVector -= cam.CFrame.LookVector end
    if directions.Right then moveVector += cam.CFrame.RightVector end
    if directions.Left then moveVector -= cam.CFrame.RightVector end
    if directions.Up then moveVector += cam.CFrame.UpVector end
    if directions.Down then moveVector -= cam.CFrame.UpVector end
    return moveVector.Magnitude > 0 and moveVector.Unit * flySpeed or Vector3.new()
end

local flyConnection
local function startFly()
    flying = true
    hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    bodyGyro = Instance.new("BodyGyro", hrp)
    bodyGyro.P = 9e4
    bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
    bodyGyro.CFrame = hrp.CFrame
    bodyVelocity = Instance.new("BodyVelocity", hrp)
    bodyVelocity.Velocity = Vector3.new()
    bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    flyConnection = RS.RenderStepped:Connect(function()
        if flying then
            bodyGyro.CFrame = workspace.CurrentCamera.CFrame
            bodyVelocity.Velocity = getDirectionVector()
        end
    end)
end

local function stopFly()
    flying = false
    if flyConnection then flyConnection:Disconnect() flyConnection = nil end
    if bodyGyro then bodyGyro:Destroy() bodyGyro = nil end
    if bodyVelocity then bodyVelocity:Destroy() bodyVelocity = nil end
    for k in pairs(directions) do directions[k] = false end
end

MainTab:CreateToggle({
    Name = "Fly",
    CurrentValue = false,
    Flag = "flyToggle",
    Callback = function(value)
        if value then startFly() else stopFly() end
    end
})

MiscTab:CreateSlider({
    Name = "Fly Speed",
    Range = {50, 700},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = flySpeed,
    Flag = "flySpeedSlider",
    Callback = function(value)
        flySpeed = value
    end
})

local noclip = false
local noclipConnection
MiscTab:CreateToggle({
    Name = "NoClip",
    CurrentValue = false,
    Flag = "noclipToggle",
    Callback = function(value)
        noclip = value
        if noclip and not noclipConnection then
            noclipConnection = game:GetService("RunService").Stepped:Connect(function()
                local char = player.Character
                if char then
                    for _, v in pairs(char:GetDescendants()) do
                        if v:IsA("BasePart") then v.CanCollide = false end
                    end
                end
            end)
        elseif not noclip and noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
    end
})
-- Nametags
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local nametagRadius = 2750
local nametagEnabled = false
local nametagFolder = Instance.new("Folder")
nametagFolder.Name = "Nametags"
nametagFolder.Parent = workspace

local playerNametags = {}
local localPlayer = Players.LocalPlayer

local function createNametag(player)
if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return nil end
local billboard = Instance.new("BillboardGui")
billboard.Name = "NametagGui"
billboard.Adornee = player.Character.HumanoidRootPart
billboard.Size = UDim2.new(0, 100, 0, 30)
billboard.StudsOffset = Vector3.new(0, 3, 0)
billboard.AlwaysOnTop = true
billboard.Parent = nametagFolder

local textLabel = Instance.new("TextLabel")
textLabel.BackgroundTransparency = 1
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.Text = player.Name
textLabel.TextColor3 = Color3.new(1, 1, 1)
textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
textLabel.TextStrokeTransparency = 0
textLabel.Font = Enum.Font.SourceSansBold
textLabel.TextScaled = true
textLabel.Parent = billboard

return billboard
end

local function updateNametags()
if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
local localHRP = localPlayer.Character.HumanoidRootPart

for _, plr in pairs(Players:GetPlayers()) do
    if plr ~= localPlayer then
        local char = plr.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local distance = (char.HumanoidRootPart.Position - localHRP.Position).Magnitude
            if distance <= nametagRadius then
                if not playerNametags[plr] then
                    playerNametags[plr] = createNametag(plr)
                end
                if playerNametags[plr] then
                    playerNametags[plr].Enabled = true
                    playerNametags[plr].Adornee = plr.Character.HumanoidRootPart
                end
            else
                if playerNametags[plr] then
                    playerNametags[plr].Enabled = false
                end
            end
        elseif playerNametags[plr] then
            playerNametags[plr]:Destroy()
            playerNametags[plr] = nil
        end
    end
end
end

local function clearNametags()
for _, gui in pairs(playerNametags) do
    if gui then gui:Destroy() end
end
playerNametags = {}
end

local function onPlayerAdded(player)
if nametagEnabled and player ~= localPlayer then
    player.CharacterAdded:Connect(function()
        task.wait(1)
        if nametagEnabled then
            if playerNametags[player] then playerNametags[player]:Destroy() end
            playerNametags[player] = createNametag(player)
        end
    end)
end
end

local function onPlayerRemoving(player)
if playerNametags[player] then
    playerNametags[player]:Destroy()
    playerNametags[player] = nil
end
end

local updateConnection
local function toggleNametags(state)
nametagEnabled = state
if nametagEnabled then
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            onPlayerAdded(player)
        end
    end
    updateConnection = RunService.RenderStepped:Connect(updateNametags)
    Players.PlayerAdded:Connect(onPlayerAdded)
    Players.PlayerRemoving:Connect(onPlayerRemoving)
else
    if updateConnection then
        updateConnection:Disconnect()
        updateConnection = nil
    end
    clearNametags()
end
end

VisTab:CreateToggle({
Name = "Nametags",
Flag = "NametagsToggle",
Callback = function(state)
    toggleNametags(state)
    Rayfield:Notify({
        Title = "Nametags",
        Content = state and "Nametags Enabled" or "Nametags Disabled",
        Duration = 3
    })
end
})

VisTab:CreateSlider({
Name = "Nametag Radius",
Range = {50, 10000},
Increment = 10,
CurrentValue = nametagRadius,
Flag = "NametagRadiusSlider",
Callback = function(value)
    nametagRadius = value
end
})
-- player Teleportation
MiscTab:CreateLabel("Player Teleportation")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local playerNames = {}
for _, player in pairs(Players:GetPlayers()) do
if player ~= LocalPlayer then
    table.insert(playerNames, player.Name)
end
end
if #playerNames == 0 then
playerNames = {"No players found"}
end

local selectedPlayerName = nil

local playerDropdown = MiscTab:CreateDropdown({
Name = "Select Player",
Options = playerNames,
CurrentOption = playerNames[1],
MultipleOptions = false,
Flag = "PlayerDropdown",
Callback = function(selection)
    selectedPlayerName = table.concat(selection, ", ")
    Rayfield:Notify({
        Title = "Player Selected",
        Content = "You selected: " .. selectedPlayerName,
        Duration = 3,
    })
end
})

-- Teleport Button
MiscTab:CreateButton({
Name = "Teleport to Player",
Callback = function()
    if selectedPlayerName == nil or selectedPlayerName == "No players found" then
        Rayfield:Notify({
            Title = "Error",
            Content = "No valid target player selected.",
            Duration = 3,
        })
        return
    end

    local targetPlayer = Players:FindFirstChild(selectedPlayerName)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
            Rayfield:Notify({
                Title = "Teleported",
                Content = "Teleported to " .. selectedPlayerName,
                Duration = 3,
            })
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "Your character or HumanoidRootPart not found.",
                Duration = 3,
            })
        end
    else
        Rayfield:Notify({
            Title = "Error",
            Content = "Target player or HumanoidRootPart not found.",
            Duration = 3,
        })
    end
end
})

local function updateDropdownOptions()
local newPlayerNames = {}
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        table.insert(newPlayerNames, player.Name)
    end
end

if #newPlayerNames == 0 then
    newPlayerNames = {"No players found"}
    selectedPlayerName = nil
else
    if selectedPlayerName == nil or not table.find(newPlayerNames, selectedPlayerName) then
        selectedPlayerName = nil
    end
end

playerDropdown:Refresh(newPlayerNames)
end

Players.PlayerAdded:Connect(updateDropdownOptions)
Players.PlayerRemoving:Connect(updateDropdownOptions)


end